import { McpAgent } from "agents/mcp";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { Hono } from "hono";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { env } from "cloudflare:workers";
import { Configuration, FrontendApi, IdentityApi } from "@ory/client-fetch";
import { jwtVerify, createRemoteJWKSet } from "jose";

type Bindings = Env;

const app = new Hono<{
  Bindings: Bindings;
}>();

type State = null;

const skyfireSellerApiKey = env.SKYFIRE_API_KEY;
const oryApiKey = env.ORY_API_KEY;
const oryProjectId = env.ORY_PROJECT_ID;
const jwksUrl = env.JWKS_URL;

// Initialize Ory clients
const oryConfig = new Configuration({
  basePath: `https://${oryProjectId}.projects.oryapis.com`,
  accessToken: oryApiKey,
  headers: {
    Authorization: `Bearer ${oryApiKey}`,
  },
});

const frontendApi = new FrontendApi(oryConfig);
const identityApi = new IdentityApi(oryConfig);
let oryResponse: string;

async function checkSession(sessionToken: string): Promise<boolean> {
  try {
    const response = await frontendApi.toSession({
      xSessionToken: sessionToken,
    });
    return response.active === true;
  } catch (error) {
    console.error("Error checking session:", error);
    return false;
  }
}

const createAccountAndLoginWithOry = async (
  kyaToken: string,
  password: string
) => {
  try {
    // Initialize JWKS client for token verification
    const JWKS = createRemoteJWKSet(new URL(jwksUrl));
    // Verify the KYA token
    const { payload } = await jwtVerify(kyaToken, JWKS, {
      issuer: env.JWT_ISSUER,
      audience: env.CARBONARC_SELLER_SERVICE_ID,
    });
    // Only for demo: randomised the email to create a new account in every run
    const skyfireEmail: string =
      Math.floor(Math.random() * 100000) + payload.bid.skyfireEmail;

    // Check if identity exists in Ory
    const identities = await identityApi.listIdentities({
      credentialsIdentifier: skyfireEmail,
    });

    let identityId: string;

    if (identities.length === 0) {
      // Create new identity if it doesn't exist
      const createResponse = await identityApi.createIdentity({
        createIdentityBody: {
          schema_id: "preset://email",
          traits: {
            email: skyfireEmail,
          },
          credentials: {
            password: {
              config: {
                password: password,
              },
            },
          },
        },
      });

      identityId = createResponse.id;
      oryResponse = "Account created successfully. ";
    } else {
      identityId = identities[0].id;
      oryResponse = "Account already exists. ";
    }

    // Create login flow
    const loginFlow = await frontendApi.createNativeLoginFlow();

    // Complete login flow
    const loginResponse = await frontendApi.updateLoginFlow({
      flow: loginFlow.id,
      updateLoginFlowBody: {
        identifier: skyfireEmail,
        password: password,
        method: "password",
      },
    });

    // Get session token
    const sessionToken = loginResponse.session_token;

    return {
      content: [
        {
          type: "text",
          text: oryResponse + `Access token is: ${sessionToken}`,
        },
      ],
    };
  } catch (error: any) {
    console.log("Error in create-account:", JSON.stringify(error));
    return {
      content: [
        {
          type: "text",
          text: `Error in account creation: ${error.message}`,
        },
      ],
    };
  }
};

export class MyMCP extends McpAgent<Bindings, State> {
  server = new McpServer({
    name: "carbonarc",
    version: "1.0.0",
    capabilities: {
      resources: {},
      tools: {},
    },
  });

  // Initialize mock data
  dataset = {
    id: 1,
    sellerId: 1,
    skyfireReceiverUsername: "CarbonArc",
    data: [
      {
        id: 1,
        dataId: 1,
        title: "US Automobile Data - 2024",
        size: "20MB",
        description: "Data specifically for the year of 2024.",
        price: "0.002",
        sampleDataFormat: {
          type: "csv",
          headers: "Manufacturer,Model,Month,Unit Sales",
        },
        dataUrl:
          "https://pub-303d212fa4df4073b8b38b3de4a72d89.r2.dev/CarbonArc/demo-dataset1.csv",
      },
      {
        id: 2,
        dataId: 2,
        title: "US Automobile Data - 2025",
        size: "10MB",
        description: "Data specifically for the year of 2025.",
        price: "0.001",
        sampleDataFormat: {
          type: "csv",
          headers: "Manufacturer,Model,Month,Unit Sales",
        },
        dataUrl:
          "https://pub-303d212fa4df4073b8b38b3de4a72d89.r2.dev/CarbonArc/demo-dataset2.csv",
      },
    ],
  };

  async init() {
    this.server.tool(
      "create-account-and-login",
      `Having an account with CarbonArc is mandatory to access its tools. This tool creates account for current buyer agent 
      using the KYA token generated by Skyfire and an agent generated new secure regex password that must contain minimum of 8, 
      maximum of 12 alphanumeric characters including atleast 1 uppercase character, 1 numeric character and 1 special character.
      On successful account creation, access token is returned`,
      {
        kyaToken: z
          .string()
          .describe(
            "KYA token generated by Skyfire to be used by CarbonArc for account creation"
          ),
        password: z.string().describe(
          `Secure random new regex password generated by agent that contains minimum 8, maximum 12 alphanumeric characters including atleast 
            1 uppercase character, 1 numeric character and 1 special character`
        ),
      },
      async ({ kyaToken, password }) => {
        return createAccountAndLoginWithOry(kyaToken, password);
      }
    );

    this.server.tool(
      "search-dataset",
      `Access token is mandatory to access this tool. This tool returns the list of datasets matching the input prompt. 
      Each dataset has dataset_id which could be further used in other tools`,
      {
        input_prompt: z.string().describe("Input prompt for searching dataset"),
        accessToken: z
          .string()
          .describe("Access token required to access and execute this tool"),
      },
      async ({ accessToken }) => {
        let isSessionValid = await checkSession(accessToken);
        if (accessToken.length !== 0 && isSessionValid) {
          let response = `Following is the comma separated list of data available from seller ${this.dataset.skyfireReceiverUsername}. 
          Each entry has an id, title and size associated.`;

          for (let i = 0; i < this.dataset.data.length; i++) {
            response =
              response +
              this.dataset.data[i].id +
              ", " +
              this.dataset.data[i].title +
              ", " +
              this.dataset.data[i].size +
              ", " +
              this.dataset.data[i].sampleDataFormat.headers +
              "\n";
          }

          return {
            content: [
              {
                type: "text",
                text: response,
              },
            ],
          };
        } else {
          return {
            content: [
              {
                type: "text",
                text: "Signed up already? Sign in now to search the available datasets",
              },
            ],
          };
        }
      }
    );

    this.server.tool(
      "get-pricing",
      "Access token is mandatory to access this tool. This tool gets pricing for the dataset_id provided",
      {
        accessToken: z
          .string()
          .describe("Access token required to access and execute this tool"),
        dataset_id: z.number().describe("ID for chosen dataset"),
      },
      async ({ accessToken, dataset_id }) => {
        let isSessionValid = await checkSession(accessToken);

        if (accessToken.length !== 0 && isSessionValid) {
          const res = this.dataset.data.filter((data) => {
            return data.dataId === dataset_id;
          });

          return {
            content: [
              {
                type: "text",
                text: `Pricing for selected dataset is ${res[0].price}`,
              },
            ],
          };
        } else {
          return {
            content: [
              {
                type: "text",
                text: `Signed up already? Sign in now to get pricing for the dataset ${dataset_id}`,
              },
            ],
          };
        }
      }
    );

    this.server.tool(
      "download-dataset",
      `Access token is mandatory to access this tool. Payment should already be executed and JWT PAY token generated by Skyfire is required.
      This tool returns the dataset url for the selected dataset_id`,
      {
        accessToken: z
          .string()
          .describe("Access token required to access and execute this tool"),
        dataset_id: z.number().describe("ID for chosen dataset"),
        payToken: z
          .string()
          .jwt()
          .describe(
            "PAY token (JWT) generated by Skyfire for verifying and claiming payment"
          ),
      },

      async ({ accessToken, dataset_id, payToken }) => {
        let isSessionValid = await checkSession(accessToken);

        if (accessToken.length !== 0 && isSessionValid) {
          const currentDataset = this.dataset.data.filter((data) => {
            return data.dataId === dataset_id;
          });

          const chargeAmount = currentDataset[0].price;

          const response = await fetch(
            `${env.SKYFIRE_API_BASE_URL}/api/v1/tokens/charge`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "skyfire-api-key": skyfireSellerApiKey,
              },
              body: JSON.stringify({
                token: payToken,
                chargeAmount: chargeAmount,
              }),
            }
          );

          const res: {
            amountCharged: string;
            remainingBalance: string;
          } = await response.json();

          if (res.amountCharged === chargeAmount) {
            return {
              content: [
                {
                  type: "text",
                  text: `Purchased dataset ${dataset_id}. Download from ${this.dataset.data[dataset_id - 1].dataUrl}`,
                },
              ],
            };
          }

          return {
            content: [
              {
                type: "text",
                text: `Unable to complete transaction. Contact us for more details.`,
              },
            ],
          };
        } else {
          return {
            content: [
              {
                type: "text",
                text: `Signed up already? Sign in now to download the dataset ${dataset_id}`,
              },
            ],
          };
        }
      }
    );
  }
}

// Render a basic homepage placeholder to make sure the app is up
app.get("/", async (c) => {
  return c.html("Home Page for CarbonArc Seller MCP Server");
});

app.mount("/", (req, env, ctx) => {
  return MyMCP.mount("/sse").fetch(req, env, ctx);
});

export default app;